[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "nbdev-sqlite-utils",
    "section": "",
    "text": "Note that rst2ipynb was written for demonstration purposes and has the following known issues:\n\ndoes not convert all links correctly\ndoes not convert numbered lists correctly\ndoes not convert tables correctly\ndoes not understand certain sphinx directives"
  },
  {
    "objectID": "rst2ipynb.html",
    "href": "rst2ipynb.html",
    "title": "rst2ipynb",
    "section": "",
    "text": "source\n\nref_role\n\n ref_role (name, rawtext, text, lineno, inliner, options=None,\n           content=None)\n\nCustom ref role.\n\nsource\n\n\nparse_rst\n\n parse_rst (fname)\n\nParse a .rst file.\n\nsource\n\n\nNotebookVisitor\n\n NotebookVisitor (*args, **kwargs)\n\nConvert an rst document into notebook cells.\n\nsource\n\n\nrst2ipynb\n\n rst2ipynb (fname:str)\n\nConvert a .rst file to .ipynb.\n\n\n\n\nType\nDetails\n\n\n\n\nfname\nstr\nPath to .rst file"
  },
  {
    "objectID": "python-api.html",
    "href": "python-api.html",
    "title": "sqlite_utils Python library",
    "section": "",
    "text": "Note: the notebook does not currently execute end-to-end due to issue #235."
  },
  {
    "objectID": "python-api.html#getting-started",
    "href": "python-api.html#getting-started",
    "title": "sqlite_utils Python library",
    "section": "Getting started",
    "text": "Getting started\nHere’s how to create a new SQLite database file containing a new chickens table, populated with four records:\n\nfrom sqlite_utils import Database\nfrom sqlite_utils.utils import sqlite3\n\n\ndb = Database(\"../test/chickens.db\")\ndb[\"chickens\"].insert_all([{\n    \"name\": \"Azi\",\n    \"color\": \"blue\",\n}, {\n    \"name\": \"Lila\",\n    \"color\": \"blue\",\n}, {\n    \"name\": \"Suna\",\n    \"color\": \"gold\",\n}, {\n    \"name\": \"Cardi\",\n    \"color\": \"black\",\n}]);\n\nYou can loop through those rows like this:\n\nfor row in db[\"chickens\"].rows:\n    print(row)\n\n{'name': 'Azi', 'color': 'blue'}\n{'name': 'Lila', 'color': 'blue'}\n{'name': 'Suna', 'color': 'gold'}\n{'name': 'Cardi', 'color': 'black'}\n\n\nTo run a SQL query, use db.query():\n\nfor row in db.query(\"\"\"\n    select color, count(*)\n    from chickens group by color\n    order by count(*) desc\n\"\"\"):\n    print(row)\n\n{'color': 'blue', 'count(*)': 2}\n{'color': 'gold', 'count(*)': 1}\n{'color': 'black', 'count(*)': 1}"
  },
  {
    "objectID": "python-api.html#connecting-to-or-creating-a-database",
    "href": "python-api.html#connecting-to-or-creating-a-database",
    "title": "sqlite_utils Python library",
    "section": "Connecting to or creating a database",
    "text": "Connecting to or creating a database\nDatabase objects are constructed by passing in either a path to a file on disk or an existing SQLite3 database connection:\n\ndb = Database(\"../test/my_database.db\")\n\nThis will create ../test/my_database.db if it does not already exist.\nIf you want to recreate a database from scratch (first removing the existing file from disk if it already exists) you can use the recreate=True argument:\n\ndb = Database(\"../test/my_database.db\", recreate=True)\n\nInstead of a file path you can pass in an existing SQLite connection:\n\ndb = Database(sqlite3.connect(\"../test/my_database.db\"))\n\nIf you want to create an in-memory database, you can do so like this:\n\ndb = Database(memory=True)\n\nYou can also create a named in-memory database. Unlike regular memory databases these can be accessed by multiple threads, provided at least one reference to the database still exists. del db will clear the database from memory.\n\ndb = Database(memory_name=\"my_shared_database\")\n\nConnections use PRAGMA recursive_triggers=on by default. If you don’t want to use recursive triggers you can turn them off using:\n\ndb = Database(memory=True, recursive_triggers=False)\n\n\nAttaching additional databases\nSQLite supports cross-database SQL queries, which can join data from tables in more than one database file.\nYou can attach an additional database using the .attach() method, providing an alias to use for that database and the path to the SQLite file on disk.\n\nDatabase(\"../test/first.db\", recreate=True)[\"table_in_first\"].insert({\"color\": \"blue\"})\nDatabase(\"../test/second.db\", recreate=True)[\"table_in_second\"].insert({\"color\": \"red\"});\n\n\ndb = Database(\"../test/first.db\")\ndb.attach(\"second\", \"../test/second.db\")\n\nNow you can run queries like this one:\n\nfor row in db.query(\"\"\"\nselect * from table_in_first\n    union all\nselect * from second.table_in_second\n\"\"\"):\n    print(row)\n\n{'color': 'blue'}\n{'color': 'red'}\n\n\nYou can reference tables in the attached database using the alias value you passed to db.attach(alias, filepath) as a prefix, for example the second.table_in_second reference in the SQL query above.\n\n\nTracing queries\nYou can use the tracer mechanism to see SQL queries that are being executed by SQLite. A tracer is a function that you provide which will be called with sql and params arguments every time SQL is executed, for example:\n\ndef tracer(sql, params):\n    print(\"SQL: {} - params: {}\".format(sql, params))\n\nYou can pass this function to the Database() constructor like so:\n\ndb = Database(memory=True, tracer=tracer)\n\nSQL: PRAGMA recursive_triggers=on; - params: None\n\n\nYou can also turn on a tracer function temporarily for a block of code using the with db.tracer(...) context manager:\n\ndb = Database(memory=True)\n# ... later\nwith db.tracer(print):\n    db[\"dogs\"].insert({\"name\": \"Cleo\"})\n\nselect name from sqlite_master where type = 'view' None\nselect name from sqlite_master where type = 'table' None\nselect name from sqlite_master where type = 'view' None\nCREATE TABLE [dogs] (\n   [name] TEXT\n);\n         None\nselect name from sqlite_master where type = 'view' None\nINSERT INTO [dogs] ([name]) VALUES (?); ['Cleo']\n\n\nThis example will print queries only for the duration of the with block."
  },
  {
    "objectID": "python-api.html#executing-queries",
    "href": "python-api.html#executing-queries",
    "title": "sqlite_utils Python library",
    "section": "Executing queries",
    "text": "Executing queries\nThe Database class offers several methods for directly executing SQL queries.\n\ndb.query(sql, params)\nThe db.query(sql) function executes a SQL query and returns an iterator over Python dictionaries representing the resulting rows:\n\ndb = Database(memory=True)\nfor row in db.query(\"select * from dogs\"):\n    print(row)\n\n{'name': 'Cleo'}\n{'name': 'Pancakes'}\n\n\n\n\ndb.execute(sql, params)\nThe db.execute() and db.executescript() methods provide wrappers around .execute() and .executescript() on the underlying SQLite connection. These wrappers log to the tracer if one has been registered.\ndb.execute(sql) returns a sqlite3.Cursor that was used to execute the SQL.\n\ncursor = db.execute(\"update dogs set name = 'Cleopaws'\")\n# Outputs the number of rows affected by the update\ncursor.rowcount\n\n2\n\n\nOther cursor methods such as .fetchone() and .fetchall() are also available, see the standard library documentation\n\n\nPassing parameters\nBoth db.query() and db.execute() accept an optional second argument for parameters to be passed to the SQL query.\nThis can take the form of either a tuple/list or a dictionary, depending on the type of parameters used in the query. Values passed in this way will be correctly quoted and escaped, helping avoid SQL injection vulnerabilities.\n? parameters in the SQL query can be filled in using a list:\n\ndb.execute(\"update dogs set name = ?\", [\"Cleopaws\"]);\n# This will rename ALL dogs to be called \"Cleopaws\"\n\nNamed parameters using :name can be filled using a dictionary:\n\nnext(db.query(\n    \"select rowid, name from dogs where name = :name\",\n    {\"name\": \"Cleopaws\"}\n))\n\n{'rowid': 1, 'name': 'Cleopaws'}\n\n\nIn this example next() is used to retrieve the first result in the iterator returned by the db.query() method."
  },
  {
    "objectID": "python-api.html#accessing-tables",
    "href": "python-api.html#accessing-tables",
    "title": "sqlite_utils Python library",
    "section": "Accessing tables",
    "text": "Accessing tables\nTables are accessed using the indexing operator, like so:\n\ntable = db[\"my_table\"]\n\nIf the table does not yet exist, it will be created the first time you attempt to insert or upsert data into it.\nYou can also access tables using the .table() method like so:\n\ntable = db.table(\"my_table\")\n\nUsing this factory function allows you to set python_api_table_configuration."
  },
  {
    "objectID": "python-api.html#listing-tables",
    "href": "python-api.html#listing-tables",
    "title": "sqlite_utils Python library",
    "section": "Listing tables",
    "text": "Listing tables\nYou can list the names of tables in a database using the .table_names() method:\n\ndb.table_names()\n\n['dogs']\n\n\nTo see just the FTS4 tables, use .table_names(fts4=True). For FTS5, use .table_names(fts5=True).\nYou can also iterate through the table objects themselves using the .tables property:\n\ndb.tables\n\n[<Table dogs (name)>]"
  },
  {
    "objectID": "python-api.html#listing-views",
    "href": "python-api.html#listing-views",
    "title": "sqlite_utils Python library",
    "section": "Listing views",
    "text": "Listing views\n.view_names() shows you a list of views in the database:\n\ndb.view_names()\n\n['good_dogs']\n\n\nYou can iterate through view objects using the .views property:\n\ndb.views\n\n[<View good_dogs (name)>]\n\n\nView objects are similar to Table objects, except that any attempts to insert or update data will throw an error. The full list of methods and properties available on a view object is as follows:\ncolumns\ncolumns_dict\ncount\nschema\nrows\nrows_where(where, where_args, order_by, select)\ndrop()"
  },
  {
    "objectID": "python-api.html#listing-rows",
    "href": "python-api.html#listing-rows",
    "title": "sqlite_utils Python library",
    "section": "Listing rows",
    "text": "Listing rows\nTo iterate through dictionaries for each of the rows in a table, use .rows:\n\ndb = Database(\"../test/dogs.db\")\nfor row in db[\"dogs\"].rows:\n    print(row)\n\n{'id': 1, 'age': 4, 'name': 'Cleo'}\n{'id': 2, 'age': 2, 'name': 'Pancakes'}\n\n\nYou can filter rows by a WHERE clause using .rows_where(where, where_args):\n\nfor row in db[\"dogs\"].rows_where(\"age > ?\", [3]):\n    print(row)\n\n{'id': 1, 'age': 4, 'name': 'Cleo'}\n\n\nThe first argument is a fragment of SQL. The second, optional argument is values to be passed to that fragment - you can use ? placeholders and pass an array, or you can use :named parameters and pass a dictionary, like this:\n\nfor row in db[\"dogs\"].rows_where(\"age > :age\", {\"age\": 3}):\n    print(row)\n\n{'id': 1, 'age': 4, 'name': 'Cleo'}\n\n\nTo return custom columns (instead of the default that uses select *) pass select=\"column1, column2\":\n\nfor row in db[\"dogs\"].rows_where(select='name, age'):\n    print(row)\n\n{'name': 'Cleo', 'age': 4}\n{'name': 'Pancakes', 'age': 2}\n\n\nTo specify an order, use the order_by= argument:\n\nfor row in db[\"dogs\"].rows_where(\"age > 1\", order_by=\"age\"):\n    print(row)\n\n{'id': 2, 'age': 2, 'name': 'Pancakes'}\n{'id': 1, 'age': 4, 'name': 'Cleo'}\n\n\nYou can use order_by=\"age desc\" for descending order.\nYou can order all records in the table by excluding the where argument:\n\nfor row in db[\"dogs\"].rows_where(order_by=\"age desc\"):\n    print(row)\n\n{'id': 1, 'age': 4, 'name': 'Cleo'}\n{'id': 2, 'age': 2, 'name': 'Pancakes'}\n\n\nThis method also accepts offset= and limit= arguments, for specifying an OFFSET and a LIMIT for the SQL query:\n\nfor row in db[\"dogs\"].rows_where(order_by=\"age desc\", limit=1):\n    print(row)\n\n{'id': 1, 'age': 4, 'name': 'Cleo'}\n\n\n\nCounting rows\nTo count the number of rows that would be returned by a where filter, use .count_where(where, where_args):\n\ndb[\"dogs\"].count_where(\"age > 1\")\n\n2"
  },
  {
    "objectID": "python-api.html#listing-rows-with-their-primary-keys",
    "href": "python-api.html#listing-rows-with-their-primary-keys",
    "title": "sqlite_utils Python library",
    "section": "Listing rows with their primary keys",
    "text": "Listing rows with their primary keys\nSometimes it can be useful to retrieve the primary key along with each row, in order to pass that key (or primary key tuple) to the .get() or .update() methods.\nThe .pks_and_rows_where() method takes the same signature as .rows_where() (with the exception of the select= parameter) but returns a generator that yields pairs of (primary key, row dictionary).\nThe primary key value will usually be a single value but can also be a tuple if the table has a compound primary key.\nIf the table is a rowid table (with no explicit primary key column) then that ID will be returned.\n\ndb = Database(memory=True)\ndb[\"dogs\"].insert({\"name\": \"Cleo\"})\nfor pk, row in db[\"dogs\"].pks_and_rows_where():\n    print(pk, row)\n\n1 {'rowid': 1, 'name': 'Cleo'}\n\n\n\ndb[\"dogs_with_pk\"].insert({\"id\": 5, \"name\": \"Cleo\"}, pk=\"id\")\nfor pk, row in db[\"dogs_with_pk\"].pks_and_rows_where():\n    print(pk, row)\n\n5 {'id': 5, 'name': 'Cleo'}\n\n\n\ndb[\"dogs_with_compound_pk\"].insert(\n    {\"species\": \"dog\", \"id\": 3, \"name\": \"Cleo\"},\n    pk=(\"species\", \"id\")\n)\nfor pk, row in db[\"dogs_with_compound_pk\"].pks_and_rows_where():\n    print(pk, row)\n\n('dog', 3) {'species': 'dog', 'id': 3, 'name': 'Cleo'}"
  },
  {
    "objectID": "python-api.html#retrieving-a-specific-record",
    "href": "python-api.html#retrieving-a-specific-record",
    "title": "sqlite_utils Python library",
    "section": "Retrieving a specific record",
    "text": "Retrieving a specific record\nYou can retrieve a record by its primary key using table.get():\n\ndb = Database(\"../test/dogs.db\")\ndb[\"dogs\"].get(1)\n\n{'id': 1, 'age': 4, 'name': 'Cleo'}\n\n\nIf the table has a compound primary key you can pass in the primary key values as a tuple:\n\ndb[\"compound_dogs\"].get((\"mixed\", 3))\n\n{'species': 'mixed', 'id': 3, 'name': 'Axel'}\n\n\nIf the record does not exist a NotFoundError will be raised:\n\nfrom sqlite_utils.db import NotFoundError\n\n\ntry:\n    row = db[\"dogs\"].get(5)\nexcept NotFoundError:\n    print(\"Dog not found\")\n\nDog not found"
  },
  {
    "objectID": "python-api.html#showing-the-schema",
    "href": "python-api.html#showing-the-schema",
    "title": "sqlite_utils Python library",
    "section": "Showing the schema",
    "text": "Showing the schema\nThe db.schema property returns the full SQL schema for the database as a string:\n\ndb = Database(\"../test/dogs.db\")\nprint(db.schema)\n\nCREATE TABLE [dogs] (\n   [id] INTEGER,\n   [age] INTEGER,\n   [name] TEXT\n);\nCREATE TABLE [compound_dogs] (\n   [species] TEXT,\n   [id] INTEGER,\n   [name] TEXT,\n   PRIMARY KEY ([species], [id])\n);"
  },
  {
    "objectID": "python-api.html#creating-tables",
    "href": "python-api.html#creating-tables",
    "title": "sqlite_utils Python library",
    "section": "Creating tables",
    "text": "Creating tables\nThe easiest way to create a new table is to insert a record into it:\n\ndb = Database(memory=True)\ndogs = db[\"dogs\"]\ndogs.insert({\n    \"name\": \"Cleo\",\n    \"twitter\": \"cleopaws\",\n    \"age\": 3,\n    \"is_good_dog\": True,\n});\n\nThis will automatically create a new table called “dogs” with the following schema:\n\nprint(dogs.schema)\n\nCREATE TABLE [dogs] (\n   [name] TEXT,\n   [twitter] TEXT,\n   [age] INTEGER,\n   [is_good_dog] INTEGER\n)\n\n\nYou can also specify a primary key by passing the pk= parameter to the .insert() call. This will only be obeyed if the record being inserted causes the table to be created:\n\ndb = Database(memory=True)\ndogs = db[\"dogs\"]\ndb[\"dogs\"].insert({\n    \"id\": 1,\n    \"name\": \"Cleo\",\n    \"twitter\": \"cleopaws\",\n    \"age\": 3,\n    \"is_good_dog\": True,\n}, pk=\"id\");\n\nAfter inserting a row like this, the dogs.last_rowid property will return the SQLite rowid assigned to the most recently inserted record.\n\ndogs.last_rowid\n\nThe dogs.last_pk property will return the last inserted primary key value, if you specified one. This can be very useful when writing code that creates foreign keys or many-to-many relationships.\n\ndogs.last_pk\n\n\nCustom column order and column types\nThe order of the columns in the table will be derived from the order of the keys in the dictionary, provided you are using Python 3.6 or later.\nIf you want to explicitly set the order of the columns you can do so using the column_order= parameter:\n\ndb = Database(memory=True)\ndb[\"dogs\"].insert({\n    \"id\": 1,\n    \"name\": \"Cleo\",\n    \"twitter\": \"cleopaws\",\n    \"age\": 3,\n    \"is_good_dog\": True,\n}, pk=\"id\", column_order=(\"id\", \"twitter\", \"name\"));\n\nYou don’t need to pass all of the columns to the column_order parameter. If you only pass a subset of the columns the remaining columns will be ordered based on the key order of the dictionary.\nColumn types are detected based on the example data provided. Sometimes you may find you need to over-ride these detected types - to create an integer column for data that was provided as a string for example, or to ensure that a table where the first example was None is created as an INTEGER rather than a TEXT column. You can do this using the columns= parameter:\n\ndb = Database(memory=True)\ndb[\"dogs\"].insert({\n    \"id\": 1,\n    \"name\": \"Cleo\",\n    \"age\": \"5\",\n}, pk=\"id\", columns={\"age\": int, \"weight\": float});\n\nThis will create a table with the following schema:\n\nprint(db[\"dogs\"].schema)\n\nCREATE TABLE [dogs] (\n   [id] INTEGER PRIMARY KEY,\n   [name] TEXT,\n   [age] INTEGER,\n   [weight] FLOAT\n)\n\n\n\n\nExplicitly creating a table\nYou can directly create a new table without inserting any data into it using the .create() method:\n\ndb = Database(memory=True)\ndb[\"cats\"].create({\n    \"id\": int,\n    \"name\": str,\n    \"weight\": float,\n}, pk=\"id\");\n\nThe first argument here is a dictionary specifying the columns you would like to create. Each column is paired with a Python type indicating the type of column. See python_api_add_column for full details on how these types work.\nThis method takes optional arguments pk=, column_order=, foreign_keys=, not_null=set() and defaults=dict() - explained below.\nA sqlite_utils.utils.sqlite3.OperationalError will be raised if a table of that name already exists.\nTo do nothing if the table already exists, add if_not_exists=True:\n\ndb[\"cats\"].create({\n    \"id\": int,\n    \"name\": str,\n    \"weight\": float,\n}, pk=\"id\", if_not_exists=True);\n\n\n\nCompound primary keys\nIf you want to create a table with a compound primary key that spans multiple columns, you can do so by passing a tuple of column names to any of the methods that accept a pk= parameter. For example:\n\ndb = Database(memory=True)\ndb[\"cats\"].create({\n    \"id\": int,\n    \"breed\": str,\n    \"name\": str,\n    \"weight\": float,\n}, pk=(\"breed\", \"id\"));\n\nThis also works for the .insert(), .insert_all(), .upsert() and .upsert_all() methods.\n\n\nSpecifying foreign keys\nAny operation that can create a table (.create(), .insert(), .insert_all(), .upsert() and .upsert_all()) accepts an optional foreign_keys= argument which can be used to set up foreign key constraints for the table that is being created.\nIf you are using your database with Datasette, Datasette will detect these constraints and use them to generate hyperlinks to associated records.\nThe foreign_keys argument takes a list that indicates which foreign keys should be created. The list can take several forms. The simplest is a list of columns:\nforeign_keys=[\"author_id\"]\nThe library will guess which tables you wish to reference based on the column names using the rules described in python_api_add_foreign_key.\nYou can also be more explicit, by passing in a list of tuples:\nforeign_keys=[\n    (\"author_id\", \"authors\", \"id\")\n]\nThis means that the author_id column should be a foreign key that references the id column in the authors table.\nYou can leave off the third item in the tuple to have the referenced column automatically set to the primary key of that table. A full example:\n\ndb = Database(memory=True)\ndb[\"authors\"].insert_all([\n    {\"id\": 1, \"name\": \"Sally\"},\n    {\"id\": 2, \"name\": \"Asheesh\"}\n], pk=\"id\")\ndb[\"books\"].insert_all([\n    {\"title\": \"Hedgehogs of the world\", \"author_id\": 1},\n    {\"title\": \"How to train your wolf\", \"author_id\": 2},\n], foreign_keys=[\n    (\"author_id\", \"authors\")\n]);"
  },
  {
    "objectID": "python-api.html#table-configuration-options",
    "href": "python-api.html#table-configuration-options",
    "title": "sqlite_utils Python library",
    "section": "Table configuration options",
    "text": "Table configuration options\nThe .insert(), .upsert(), .insert_all() and .upsert_all() methods each take a number of keyword arguments, some of which influence what happens should they cause a table to be created and some of which affect the behavior of those methods.\nYou can set default values for these methods by accessing the table through the db.table(...) method (instead of using db[\"table_name\"]), like so:\n\ndb = Database(memory=True)\nauthors = db.table(\n    \"authors\",\n    pk=\"id\",\n    not_null={\"name\", \"score\"},\n    column_order=(\"id\", \"name\", \"score\", \"url\")\n)\n\nNow you can call .insert() like so:\n\nauthors.insert({\"id\": 1, \"name\": \"Tracy\", \"score\": 5});\n\nThe configuration options that can be specified in this way are pk, foreign_keys, column_order, not_null, defaults, batch_size, hash_id, hash_id_columns, alter, ignore, replace, extracts, conversions, columns. These are all documented below."
  },
  {
    "objectID": "python-api.html#setting-defaults-and-not-null-constraints",
    "href": "python-api.html#setting-defaults-and-not-null-constraints",
    "title": "sqlite_utils Python library",
    "section": "Setting defaults and not null constraints",
    "text": "Setting defaults and not null constraints\nEach of the methods that can cause a table to be created take optional arguments not_null=set() and defaults=dict(). The methods that take these optional arguments are:\ndb.create_table(...)\ntable.create(...)\ntable.insert(...)\ntable.insert_all(...)\ntable.upsert(...)\ntable.upsert_all(...)\nYou can use not_null= to pass a set of column names that should have a NOT NULL constraint set on them when they are created.\nYou can use defaults= to pass a dictionary mapping columns to the default value that should be specified in the CREATE TABLE statement.\nHere’s an example that uses these features:\n\ndb = Database(memory=True)\ndb[\"authors\"].insert_all(\n    [{\"id\": 1, \"name\": \"Sally\", \"score\": 2}],\n    pk=\"id\",\n    not_null={\"name\", \"score\"},\n    defaults={\"score\": 1},\n)\ndb[\"authors\"].insert({\"name\": \"Dharma\"})\nlist(db[\"authors\"].rows)\n\n[{'id': 1, 'name': 'Sally', 'score': 2},\n {'id': 2, 'name': 'Dharma', 'score': 1}]\n\n\n\nprint(db[\"authors\"].schema)\n\nCREATE TABLE [authors] (\n   [id] INTEGER PRIMARY KEY,\n   [name] TEXT NOT NULL,\n   [score] INTEGER NOT NULL DEFAULT 1\n)"
  },
  {
    "objectID": "python-api.html#duplicating-tables",
    "href": "python-api.html#duplicating-tables",
    "title": "sqlite_utils Python library",
    "section": "Duplicating tables",
    "text": "Duplicating tables\nThe table.duplicate() method creates a copy of the table, copying both the table schema and all of the rows in that table:\n\nauthors_copy = db[\"authors\"].duplicate(\"authors_copy\")\n\nThe new authors_copy table will now contain a duplicate copy of the data from authors.\nThis method raises sqlite_utils.db.NoTable if the table does not exist."
  },
  {
    "objectID": "python-api.html#bulk-inserts",
    "href": "python-api.html#bulk-inserts",
    "title": "sqlite_utils Python library",
    "section": "Bulk inserts",
    "text": "Bulk inserts\nIf you have more than one record to insert, the insert_all() method is a much more efficient way of inserting them. Just like insert() it will automatically detect the columns that should be created, but it will inspect the first batch of 100 items to help decide what those column types should be.\nUse it like this:\n\ndb = Database(memory=True)\ndb[\"dogs\"].insert_all([{\n    \"id\": 1,\n    \"name\": \"Cleo\",\n    \"twitter\": \"cleopaws\",\n    \"age\": 3,\n    \"is_good_dog\": True,\n}, {\n    \"id\": 2,\n    \"name\": \"Marnie\",\n    \"twitter\": \"MarnieTheDog\",\n    \"age\": 16,\n    \"is_good_dog\": True,\n}], pk=\"id\", column_order=(\"id\", \"twitter\", \"name\"));\n\nThe column types used in the CREATE TABLE statement are automatically derived from the types of data in that first batch of rows. Any additional columns in subsequent batches will cause a sqlite3.OperationalError exception to be raised unless the alter=True argument is supplied, in which case the new columns will be created.\nThe function can accept an iterator or generator of rows and will commit them according to the batch size. The default batch size is 100, but you can specify a different size using the batch_size parameter:\n\ndb[\"big_table\"].insert_all(({\n    \"id\": 1,\n    \"name\": \"Name {}\".format(i),\n} for i in range(10000)), batch_size=1000);\n\nYou can skip inserting any records that have a primary key that already exists using ignore=True. This works with both .insert({...}, ignore=True) and .insert_all([...], ignore=True).\nYou can delete all the existing rows in the table before inserting the new records using truncate=True. This is useful if you want to replace the data in the table.\nPass analyze=True to run ANALYZE against the table after inserting the new records."
  },
  {
    "objectID": "python-api.html#insert-replacing-data",
    "href": "python-api.html#insert-replacing-data",
    "title": "sqlite_utils Python library",
    "section": "Insert-replacing data",
    "text": "Insert-replacing data\nIf you try to insert data using a primary key that already exists, the .insert() or .insert_all() method will raise a sqlite3.IntegrityError exception.\nThis example that catches that exception:\n\ndb = Database(memory=True)\ndb[\"dogs\"].insert({\"id\": 1, \"name\": \"Cleo\"}, pk=\"id\")\ntry:\n    db[\"dogs\"].insert({\"id\": 1, \"name\": \"Cleo\"}, pk=\"id\")\nexcept sqlite3.IntegrityError:\n    print(\"Record already exists with that primary key\")\n\nRecord already exists with that primary key\n\n\nImporting from sqlite_utils.utils.sqlite3 ensures your code continues to work even if you are using the pysqlite3 library instead of the Python standard library sqlite3 module.\nUse the ignore=True parameter to ignore this error:\n\n# This fails silently if a record with id=1 already exists\ndb[\"dogs\"].insert({\"id\": 1, \"name\": \"Cleo\"}, pk=\"id\", ignore=True);\n\nTo replace any existing records that have a matching primary key, use the replace=True parameter to .insert() or .insert_all():\n\ndb[\"dogs\"].insert_all([{\n    \"id\": 1,\n    \"name\": \"Cleo\",\n}, {\n    \"id\": 2,\n    \"name\": \"Marnie\",\n}], pk=\"id\", replace=True);\n\n\n\n\n\n\n\nNote\n\n\n\nPrior to sqlite-utils 2.0 the .upsert() and .upsert_all() methods worked the same way as .insert(replace=True) does today. See python_api_upsert for the new behaviour of those methods introduced in 2.0."
  },
  {
    "objectID": "python-api.html#updating-a-specific-record",
    "href": "python-api.html#updating-a-specific-record",
    "title": "sqlite_utils Python library",
    "section": "Updating a specific record",
    "text": "Updating a specific record\nYou can update a record by its primary key using table.update():\n\ndb = Database(\"../test/dogs.db\")\nprint(db[\"dogs\"].get(1))\n\n{'id': 1, 'age': 4, 'name': 'Cleo'}\n\n\n\ndb[\"dogs\"].update(1, {\"age\": 5})\nprint(db[\"dogs\"].get(1))\n\n{'id': 1, 'age': 5, 'name': 'Cleo'}\n\n\nThe first argument to update() is the primary key. This can be a single value, or a tuple if that table has a compound primary key:\n\ndb[\"compound_dogs\"].update(('mixed', 3), {\"name\": \"Updated\"});\n\nThe second argument is a dictionary of columns that should be updated, along with their new values.\nYou can cause any missing columns to be added automatically using alter=True:\n\ndb[\"dogs\"].update(1, {\"breed\": \"Mutt\"}, alter=True);"
  },
  {
    "objectID": "python-api.html#deleting-a-specific-record",
    "href": "python-api.html#deleting-a-specific-record",
    "title": "sqlite_utils Python library",
    "section": "Deleting a specific record",
    "text": "Deleting a specific record\nYou can delete a record using table.delete():\n\ndb = Database(\"../test/dogs.db\")\ndb[\"dogs\"].delete(1);\n\nThe delete() method takes the primary key of the record. This can be a tuple of values if the row has a compound primary key:\n\ndb[\"compound_dogs\"].delete(('mixed', 3));"
  },
  {
    "objectID": "python-api.html#deleting-multiple-records",
    "href": "python-api.html#deleting-multiple-records",
    "title": "sqlite_utils Python library",
    "section": "Deleting multiple records",
    "text": "Deleting multiple records\nYou can delete all records in a table that match a specific WHERE statement using table.delete_where():\n\ndb = Database(\"../test/dogs.db\")\n# Delete every dog with age less than 3\ndb[\"dogs\"].delete_where(\"age < ?\", [3]);\n\nCalling table.delete_where() with no other arguments will delete every row in the table.\nPass analyze=True to run ANALYZE against the table after deleting the rows."
  },
  {
    "objectID": "python-api.html#upserting-data",
    "href": "python-api.html#upserting-data",
    "title": "sqlite_utils Python library",
    "section": "Upserting data",
    "text": "Upserting data\nUpserting allows you to insert records if they do not exist and update them if they DO exist, based on matching against their primary key.\nFor example, given the dogs database you could upsert the record for Cleo like so:\n\ndb = Database(memory=True)\ndb[\"dogs\"].upsert({\n    \"id\": 1,\n    \"name\": \"Cleo\",\n    \"twitter\": \"cleopaws\",\n    \"age\": 4,\n    \"is_good_dog\": True,\n}, pk=\"id\", column_order=(\"id\", \"twitter\", \"name\"));\n\nIf a record exists with id=1, it will be updated to match those fields. If it does not exist it will be created.\nAny existing columns that are not referenced in the dictionary passed to .upsert() will be unchanged. If you want to replace a record entirely, use .insert(doc, replace=True) instead.\nNote that the pk and column_order parameters here are optional if you are certain that the table has already been created. You should pass them if the table may not exist at the time the first upsert is performed.\nAn upsert_all() method is also available, which behaves like insert_all() but performs upserts instead.\n\n\n\n\n\n\nNote\n\n\n\n.upsert() and .upsert_all() in sqlite-utils 1.x worked like .insert(..., replace=True) and .insert_all(..., replace=True) do in 2.x. See issue #66 for details of this change."
  },
  {
    "objectID": "python-api.html#converting-data-in-columns",
    "href": "python-api.html#converting-data-in-columns",
    "title": "sqlite_utils Python library",
    "section": "Converting data in columns",
    "text": "Converting data in columns\nThe table.convert(...) method can be used to apply a conversion function to the values in a column, either to update that column or to populate new columns. It is the Python library equivalent of the sqlite-utils command.\nThis feature works by registering a custom SQLite function that applies a Python transformation, then running a SQL query equivalent to UPDATE table SET column = convert_value(column);\nTo transform a specific column to uppercase, you would use the following:\n\ndb[\"dogs\"].convert(\"name\", lambda value: value.upper());\n\nYou can pass a list of columns, in which case the transformation will be applied to each one:\n\ndb[\"dogs\"].convert([\"name\", \"twitter\"], lambda value: value.upper());\n\nTo save the output to of the transformation to a different column, use the output= parameter:\n\ndb[\"dogs\"].convert(\"name\", lambda value: value.upper(), output=\"name_upper\")\n\n<Table dogs (id, twitter, name, age, is_good_dog, name_upper)>\n\n\nThis will add the new column, if it does not already exist. You can pass output_type=int or some other type to control the type of the new column - otherwise it will default to text.\nIf you want to drop the original column after saving the results in a separate output column, pass drop=True.\nYou can create multiple new columns from a single input column by passing multi=True and a conversion function that returns a Python dictionary. This example creates new upper and lower columns populated from the single title column:\ntable.convert(\n    \"title\", lambda v: {\"upper\": v.upper(), \"lower\": v.lower()}, multi=True\n)\nThe .convert() method accepts optional where= and where_args= parameters which can be used to apply the conversion to a subset of rows specified by a where clause. Here’s how to apply the conversion only to rows with an id that is higher than 20:\ntable.convert(\"title\", lambda v: v.upper(), where=\"id > :id\", where_args={\"id\": 20})\nThese behave the same as the corresponding parameters to the .rows_where() method, so you can use ? placeholders and a list of values instead of :named placeholders with a dictionary."
  },
  {
    "objectID": "python-api.html#working-with-lookup-tables",
    "href": "python-api.html#working-with-lookup-tables",
    "title": "sqlite_utils Python library",
    "section": "Working with lookup tables",
    "text": "Working with lookup tables\nA useful pattern when populating large tables in to break common values out into lookup tables. Consider a table of Trees, where each tree has a species. Ideally these species would be split out into a separate Species table, with each one assigned an integer primary key that can be referenced from the Trees table species_id column.\n\nCreating lookup tables explicitly\nCalling db[\"Species\"].lookup({\"name\": \"Palm\"}) creates a table called Species (if one does not already exist) with two columns: id and name. It sets up a unique constraint on the name column to guarantee it will not contain duplicate rows. It then inserts a new row with the name set to Palm and returns the new integer primary key value.\nIf the Species table already exists, it will insert the new row and return the primary key. If a row with that name already exists, it will return the corresponding primary key value directly.\nIf you call .lookup() against an existing table without the unique constraint it will attempt to add the constraint, raising an IntegrityError if the constraint cannot be created.\nIf you pass in a dictionary with multiple values, both values will be used to insert or retrieve the corresponding ID and any unique constraint that is created will cover all of those columns, for example:\n\ndb = Database(memory=True)\ndb[\"Trees\"].insert({\n    \"latitude\": 49.1265976,\n    \"longitude\": 2.5496218,\n    \"species\": db[\"Species\"].lookup({\n        \"common_name\": \"Common Juniper\",\n        \"latin_name\": \"Juniperus communis\"\n    })\n});\n\nThe .lookup() method has an optional second argument which can be used to populate other columns in the table but only if the row does not exist yet. These columns will not be included in the unique index.\nTo create a species record with a note on when it was first seen, you can use this:\n\ndb[\"Species\"].lookup({\"name\": \"Palm\"}, {\"first_seen\": \"2021-03-04\"})\n\n2\n\n\nThe first time this is called the record will be created for name=\"Palm\". Any subsequent calls with that name will ignore the second argument, even if it includes different values.\n.lookup() also accepts keyword arguments, which are passed through to the insert() and can be used to influence the shape of the created table. Supported parameters are:\npk - which defaults to id\nforeign_keys\ncolumn_order\nnot_null\ndefaults\nextracts\nconversions\ncolumns\n\n\nPopulating lookup tables automatically during insert/upsert\nA more efficient way to work with lookup tables is to define them using the extracts= parameter, which is accepted by .insert(), .upsert(), .insert_all(), .upsert_all() and by the .table(...) factory function.\nextracts= specifies columns which should be “extracted” out into a separate lookup table during the data insertion.\nIt can be either a list of column names, in which case the extracted table names will match the column names exactly, or it can be a dictionary mapping column names to the desired name of the extracted table.\nTo extract the species column out to a separate Species table, you can do this:\n\n# Using the table factory\ntrees = db.table(\"Trees\", extracts={\"species\": \"Species\"})\ntrees.insert({\n    \"latitude\": 49.1265976,\n    \"longitude\": 2.5496218,\n    \"species\": \"Common Juniper\"\n})\n\n# If you want the table to be called 'species', you can do this:\ntrees = db.table(\"Trees\", extracts=[\"species\"])\n\n# Using .insert() directly\ndb[\"Trees\"].insert({\n    \"latitude\": 49.1265976,\n    \"longitude\": 2.5496218,\n    \"species\": \"Common Juniper\"\n}, extracts={\"species\": \"Species\"});"
  },
  {
    "objectID": "python-api.html#working-with-many-to-many-relationships",
    "href": "python-api.html#working-with-many-to-many-relationships",
    "title": "sqlite_utils Python library",
    "section": "Working with many-to-many relationships",
    "text": "Working with many-to-many relationships\nsqlite-utils includes a shortcut for creating records using many-to-many relationships in the form of the table.m2m(...) method.\nHere’s how to create two new records and connect them via a many-to-many table in a single line of code:\n\ndb = Database(memory=True)\ndb[\"dogs\"].insert({\"id\": 1, \"name\": \"Cleo\"}, pk=\"id\").m2m(\n    \"humans\", {\"id\": 1, \"name\": \"Natalie\"}, pk=\"id\"\n);\n\nRunning this example actually creates three tables: dogs, humans and a many-to-many dogs_humans table. It will insert a record into each of those tables.\nThe .m2m() method executes against the last record that was affected by .insert() or .update() - the record identified by the table.last_pk property. To execute .m2m() against a specific record you can first select it by passing its primary key to .update():\n\ndb[\"dogs\"].update(1).m2m(\n    \"humans\", {\"id\": 2, \"name\": \"Simon\"}, pk=\"id\"\n);\n\nThe first argument to .m2m() can be either the name of a table as a string or it can be the table object itself.\nThe second argument can be a single dictionary record or a list of dictionaries. These dictionaries will be passed to .upsert() against the specified table.\nHere’s alternative code that creates the dog record and adds two people to it:\n\ndb = Database(memory=True)\ndogs = db.table(\"dogs\", pk=\"id\")\nhumans = db.table(\"humans\", pk=\"id\")\ndogs.insert({\"id\": 1, \"name\": \"Cleo\"}).m2m(\n    humans, [\n        {\"id\": 1, \"name\": \"Natalie\"},\n        {\"id\": 2, \"name\": \"Simon\"}\n    ]\n);\n\nThe method will attempt to find an existing many-to-many table by looking for a table that has foreign key relationships against both of the tables in the relationship.\nIf it cannot find such a table, it will create a new one using the names of the two tables - dogs_humans in this example. You can customize the name of this table using the m2m_table= argument to .m2m().\nIt it finds multiple candidate tables with foreign keys to both of the specified tables it will raise a sqlite_utils.db.NoObviousTable exception. You can avoid this error by specifying the correct table using m2m_table=.\nThe .m2m() method also takes an optional pk= argument to specify the primary key that should be used if the table is created, and an optional alter=True argument to specify that any missing columns of an existing table should be added if they are needed.\n\nUsing m2m and lookup tables together\nYou can work with (or create) lookup tables as part of a call to .m2m() using the lookup= parameter. This accepts the same argument as table.lookup() does - a dictionary of values that should be used to lookup or create a row in the lookup table.\nThis example creates a dogs table, populates it, creates a characteristics table, populates that and sets up a many-to-many relationship between the two. It chains .m2m() twice to create two associated characteristics:\n\ndb = Database(memory=True)\ndogs = db.table(\"dogs\", pk=\"id\")\ndogs.insert({\"id\": 1, \"name\": \"Cleo\"}).m2m(\n    \"characteristics\", lookup={\n        \"name\": \"Playful\"\n    }\n).m2m(\n    \"characteristics\", lookup={\n        \"name\": \"Opinionated\"\n    }\n);\n\nYou can inspect the database to see the results like this:\n\ndb.table_names()\n\n['dogs', 'characteristics', 'characteristics_dogs']\n\n\n\nlist(db[\"dogs\"].rows)\n\n[{'id': 1, 'name': 'Cleo'}]\n\n\n\nlist(db[\"characteristics\"].rows)\n\n[{'id': 1, 'name': 'Playful'}, {'id': 2, 'name': 'Opinionated'}]\n\n\n\nlist(db[\"characteristics_dogs\"].rows)\n\n[{'characteristics_id': 1, 'dogs_id': 1},\n {'characteristics_id': 2, 'dogs_id': 1}]\n\n\n\nprint(db[\"characteristics_dogs\"].schema)\n\nCREATE TABLE [characteristics_dogs] (\n   [characteristics_id] INTEGER REFERENCES [characteristics]([id]),\n   [dogs_id] INTEGER REFERENCES [dogs]([id]),\n   PRIMARY KEY ([characteristics_id], [dogs_id])\n)"
  },
  {
    "objectID": "python-api.html#analyzing-a-column",
    "href": "python-api.html#analyzing-a-column",
    "title": "sqlite_utils Python library",
    "section": "Analyzing a column",
    "text": "Analyzing a column\nThe table.analyze_column(column, common_limit=10, value_truncate=None) method is used by the analyze-tables CLI command. It returns a ColumnDetails named tuple with the following fields:\ntable – The name of the table\ncolumn – The name of the column\ntotal_rows – The total number of rows in the table\nnum_null – The number of rows for which this column is null\nnum_blank – The number of rows for which this column is blank (the empty string)\nnum_distinct – The number of distinct values in this column\nmost_common – The N most common values as a list of (value, count) tuples, or None if the table consists entirely of distinct values\nleast_common – The N least common values as a list of (value, count) tuples, or None if the table is entirely distinct or if the number of distinct values is less than N (since they will already have been returned in most_common)\nN defaults to 10, or you can pass a custom N using the common_limit parameter.\nYou can use the value_truncate parameter to truncate values in the most_common and least_common lists to a specified number of characters."
  },
  {
    "objectID": "python-api.html#adding-columns",
    "href": "python-api.html#adding-columns",
    "title": "sqlite_utils Python library",
    "section": "Adding columns",
    "text": "Adding columns\nYou can add a new column to a table using the .add_column(col_name, col_type) method:\n\nimport datetime\n\n\ndb = Database(\"../test/dogs.db\")\ndb[\"dogs\"].add_column(\"instagram\", str)\ndb[\"dogs\"].add_column(\"weight\", float)\ndb[\"dogs\"].add_column(\"dob\", datetime.date)\ndb[\"dogs\"].add_column(\"image\", \"BLOB\")\ndb[\"dogs\"].add_column(\"website\"); # str by default\n\nYou can specify the col_type argument either using a SQLite type as a string, or by directly passing a Python type e.g. str or float.\nThe col_type is optional - if you omit it the type of TEXT will be used.\nSQLite types you can specify are \"TEXT\", \"INTEGER\", \"FLOAT\" or \"BLOB\".\nIf you pass a Python type, it will be mapped to SQLite types as shown here:\nfloat: \"FLOAT\"\nint: \"INTEGER\"\nbool: \"INTEGER\"\nstr: \"TEXT\"\nbytes: \"BLOB\"\ndatetime.datetime: \"TEXT\"\ndatetime.date: \"TEXT\"\ndatetime.time: \"TEXT\"\n\n# If numpy is installed\nnp.int8: \"INTEGER\"\nnp.int16: \"INTEGER\"\nnp.int32: \"INTEGER\"\nnp.int64: \"INTEGER\"\nnp.uint8: \"INTEGER\"\nnp.uint16: \"INTEGER\"\nnp.uint32: \"INTEGER\"\nnp.uint64: \"INTEGER\"\nnp.float16: \"FLOAT\"\nnp.float32: \"FLOAT\"\nnp.float64: \"FLOAT\"\nYou can also add a column that is a foreign key reference to another table using the fk parameter:\n\ndb.create_table(\"species\", {\"ref\": int, \"name\": str}, if_not_exists=True);\n# db[\"dogs\"].add_column(\"species_id\", fk=\"species\") # TODO: see https://github.com/simonw/sqlite-utils/issues/235\n\nThis will automatically detect the name of the primary key on the species table and use that (and its type) for the new column.\nYou can explicitly specify the column you wish to reference using fk_col:\n\n# db[\"dogs\"].add_column(\"species_id\", fk=\"species\", fk_col=\"ref\") # TODO: see https://github.com/simonw/sqlite-utils/issues/235\n\nYou can set a NOT NULL DEFAULT 'x' constraint on the new column using not_null_default:\n\ndb[\"dogs\"].add_column(\"friends_count\", int, not_null_default=0);"
  },
  {
    "objectID": "python-api.html#adding-columns-automatically-on-insertupdate",
    "href": "python-api.html#adding-columns-automatically-on-insertupdate",
    "title": "sqlite_utils Python library",
    "section": "Adding columns automatically on insert/update",
    "text": "Adding columns automatically on insert/update\nYou can insert or update data that includes new columns and have the table automatically altered to fit the new schema using the alter=True argument. This can be passed to all four of .insert(), .upsert(), .insert_all() and .upsert_all(), or it can be passed to db.table(table_name, alter=True) to enable it by default for all method calls against that table instance.\n\ndb = Database(memory=True)\ndb[\"new_table\"].insert({\"name\": \"Gareth\"});\n\nThis will throw an exception:\n\ntry:\n    db[\"new_table\"].insert({\"name\": \"Gareth\", \"age\": 32})\nexcept sqlite3.OperationalError as e:\n    print(e)\n\ntable new_table has no column named age\n\n\nThis will succeed and add a new “age” integer column:\n\ndb[\"new_table\"].insert({\"name\": \"Gareth\", \"age\": 32}, alter=True);\n\nYou can see confirm the new column like so:\n\ndb[\"new_table\"].columns_dict\n\n{'name': str, 'age': int}\n\n\nThis works too:\n\nnew_table = db.table(\"new_table\", alter=True)\nnew_table.insert({\"name\": \"Gareth\", \"age\": 32, \"shoe_size\": 11});"
  },
  {
    "objectID": "python-api.html#adding-foreign-key-constraints",
    "href": "python-api.html#adding-foreign-key-constraints",
    "title": "sqlite_utils Python library",
    "section": "Adding foreign key constraints",
    "text": "Adding foreign key constraints\nThe SQLite ALTER TABLE statement doesn’t have the ability to add foreign key references to an existing column.\nIt’s possible to add these references through very careful manipulation of SQLite’s sqlite_master table, using PRAGMA writable_schema.\nsqlite-utils can do this for you, though there is a significant risk of data corruption if something goes wrong so it is advisable to create a fresh copy of your database file before attempting this.\nHere’s an example of this mechanism in action:\n\ndb = Database(\"../test/books.db\", recreate=True)\ndb[\"authors\"].insert_all([\n    {\"id\": 1, \"name\": \"Sally\"},\n    {\"id\": 2, \"name\": \"Asheesh\"}\n], pk=\"id\")\ndb[\"books\"].insert_all([\n    {\"title\": \"Hedgehogs of the world\", \"author_id\": 1},\n    {\"title\": \"How to train your wolf\", \"author_id\": 2},\n])\n# db[\"books\"].add_foreign_key(\"author_id\", \"authors\", \"id\")  # TODO: see https://github.com/simonw/sqlite-utils/issues/235\n\n<Table books (title, author_id)>\n\n\nThe table.add_foreign_key(column, other_table, other_column) method takes the name of the column, the table that is being referenced and the key column within that other table. If you omit the other_column argument the primary key from that table will be used automatically. If you omit the other_table argument the table will be guessed based on some simple rules:\nIf the column is of format author_id, look for tables called author or authors\nIf the column does not end in _id, try looking for a table with the exact name of the column or that name with an added s\nThis method first checks that the specified foreign key references tables and columns that exist and does not clash with an existing foreign key. It will raise a sqlite_utils.db.AlterError exception if these checks fail.\nTo ignore the case where the key already exists, use ignore=True:\n\n# db[\"books\"].add_foreign_key(\"author_id\", \"authors\", \"id\", ignore=True) # TODO: see https://github.com/simonw/sqlite-utils/issues/235\n\n\nAdding multiple foreign key constraints at once\nThe final step in adding a new foreign key to a SQLite database is to run VACUUM, to ensure the new foreign key is available in future introspection queries.\nVACUUM against a large (multi-GB) database can take several minutes or longer. If you are adding multiple foreign keys using table.add_foreign_key(...) these can quickly add up.\nInstead, you can use db.add_foreign_keys(...) to add multiple foreign keys within a single transaction. This method takes a list of four-tuples, each one specifying a table, column, other_table and other_column.\nHere’s an example adding two foreign keys at once:\n\ndb = Database(\"../test/dogs.db\")\n# db.add_foreign_keys([\n#     (\"dogs\", \"breed_id\", \"breeds\", \"id\"),\n#     (\"dogs\", \"home_town_id\", \"towns\", \"id\")\n# ]) # TODO: see https://github.com/simonw/sqlite-utils/issues/235\n\nThis method runs the same checks as .add_foreign_keys() and will raise sqlite_utils.db.AlterError if those checks fail.\n\n\nAdding indexes for all foreign keys\nIf you want to ensure that every foreign key column in your database has a corresponding index, you can do so like this:\n\ndb.index_foreign_keys()"
  },
  {
    "objectID": "python-api.html#dropping-a-table-or-view",
    "href": "python-api.html#dropping-a-table-or-view",
    "title": "sqlite_utils Python library",
    "section": "Dropping a table or view",
    "text": "Dropping a table or view\nYou can drop a table or view using the .drop() method:\n\ndb = Database(\"../test/dogs.db\")\n\n\ndb[\"dogs\"].drop()\n\nPass ignore=True if you want to ignore the error caused by the table or view not existing.\n\ndb[\"dogs\"].drop(ignore=True)"
  },
  {
    "objectID": "python-api.html#transforming-a-table",
    "href": "python-api.html#transforming-a-table",
    "title": "sqlite_utils Python library",
    "section": "Transforming a table",
    "text": "Transforming a table\nThe SQLite ALTER TABLE statement is limited. It can add and drop columns and rename tables, but it cannot change column types, change NOT NULL status or change the primary key for a table.\nThe table.transform() method can do all of these things, by implementing a multi-step pattern described in the SQLite documentation:\n\nStart a transaction\nCREATE TABLE tablename_new_x123 with the required changes\nCopy the old data into the new table using INSERT INTO tablename_new_x123 SELECT * FROM tablename;\nDROP TABLE tablename;\nALTER TABLE tablename_new_x123 RENAME TO tablename;\nCommit the transaction\n\nThe .transform() method takes a number of parameters, all of which are optional.\n\nAltering column types\nTo alter the type of a column, use the types= argument:\n\n# Convert the 'age' column to an integer, and 'weight' to a float\ntable.transform(types={\"age\": int, \"weight\": float});\n\nSee python_api_add_column for a list of available types.\n\n\nRenaming columns\nThe rename= parameter can rename columns:\n\n# Rename 'age' to 'initial_age':\ntable.transform(rename={\"age\": \"initial_age\"});\n\n\n\nDropping columns\nTo drop columns, pass them in the drop= set:\n\n# Drop the 'age' column:\ntable.transform(drop={\"age\"});\n\n\n\nChanging primary keys\nTo change the primary key for a table, use pk=. This can be passed a single column for a regular primary key, or a tuple of columns to create a compound primary key. Passing pk=None will remove the primary key and convert the table into a rowid table.\n\n# Make `user_id` the new primary key\ntable.transform(pk=\"user_id\");\n\n\n\nChanging not null status\nYou can change the NOT NULL status of columns by using not_null=. You can pass this a set of columns to make those columns NOT NULL:\n\n# Make the 'age' and 'weight' columns NOT NULL\ntable.transform(not_null={\"age\", \"weight\"});\n\nIf you want to take existing NOT NULL columns and change them to allow null values, you can do so by passing a dictionary of true/false values instead:\n\n# 'age' is NOT NULL but we want to allow NULL:\ntable.transform(not_null={\"age\": False})\n\n# Make age allow NULL and switch weight to being NOT NULL:\ntable.transform(not_null={\"age\": False, \"weight\": True});\n\n\n\nAltering column defaults\nThe defaults= parameter can be used to set or change the defaults for different columns:\n\n# Set default age to 1:\ntable.transform(defaults={\"age\": 1})\n\n# Now remove the default from that column:\ntable.transform(defaults={\"age\": None});\n\n\n\nChanging column order\nThe column_order= parameter can be used to change the order of the columns. If you pass the names of a subset of the columns those will go first and columns you omitted will appear in their existing order after them.\n\n# Change column order\ntable.transform(column_order=(\"name\", \"age\", \"id\"));\n\n\n\nDropping foreign key constraints\nYou can use .transform() to remove foreign key constraints from a table.\nThis example drops two foreign keys - the one from places.country to country.id and the one from places.continent to continent.id:\n\ndb[\"places\"].transform(\n    drop_foreign_keys=(\"country\", \"continent\")\n);\n\n\n\nCustom transformations with .transform_sql()\nThe .transform() method can handle most cases, but it does not automatically upgrade indexes, views or triggers associated with the table that is being transformed.\nIf you want to do something more advanced, you can call the table.transform_sql(...) method with the same arguments that you would have passed to table.transform(...).\nThis method will return a list of SQL statements that should be executed to implement the change. You can then make modifications to that SQL - or add additional SQL statements - before executing it yourself."
  },
  {
    "objectID": "python-api.html#extracting-columns-into-a-separate-table",
    "href": "python-api.html#extracting-columns-into-a-separate-table",
    "title": "sqlite_utils Python library",
    "section": "Extracting columns into a separate table",
    "text": "Extracting columns into a separate table\nThe table.extract() method can be used to extract specified columns into a separate table.\nImagine a Trees table that looks like this:\n\nshow_table(db[\"Trees\"].rows)\n\n\nidTreeAddressSpecies152 Vine StPalm212 Draft StOak351 Dark AvePalm41252 Left StPalm\n\n\nThe Species column contains duplicate values. This database could be improved by extracting that column out into a separate Species table and pointing to it using a foreign key column.\nThe schema of the above table is:\n\nfrom IPython.display import Markdown\n\nCREATE TABLE [Trees] (\n   [id] INTEGER PRIMARY KEY,\n   [TreeAddress] TEXT,\n   [Species] TEXT\n)\n\nprint(db[\"Trees\"].schema)\n\nCREATE TABLE [Trees] (\n   [id] INTEGER PRIMARY KEY,\n   [TreeAddress] TEXT,\n   [Species] TEXT\n)\n\n\nHere’s how to extract the Species column using .extract():\n\n# db[\"Trees\"].extract(\"Species\") # TODO: see https://github.com/simonw/sqlite-utils/issues/235\n\nAfter running this code the table schema now looks like this:\n\nprint(db[\"Trees\"].schema)\n\nCREATE TABLE [Trees] (\n   [id] INTEGER PRIMARY KEY,\n   [TreeAddress] TEXT,\n   [Species] TEXT\n)\n\n\nA new Species table will have been created with the following schema:\n\n# print(db[\"Species\"].schema)\n\nThe .extract() method defaults to creating a table with the same name as the column that was extracted, and adding a foreign key column called tablename_id.\nYou can specify a custom table name using table=, and a custom foreign key name using fk_column=. This example creates a table called tree_species and a foreign key column called tree_species_id:\n\n# db[\"Trees\"].extract(\"Species\", table=\"tree_species\", fk_column=\"tree_species_id\") # TODO: see https://github.com/simonw/sqlite-utils/issues/235\n\nThe resulting schema looks like this:\n\nprint(db[\"Trees\"].schema)\n\nCREATE TABLE [Trees] (\n   [id] INTEGER PRIMARY KEY,\n   [TreeAddress] TEXT,\n   [Species] TEXT\n)\n\n\nYou can also extract multiple columns into the same external table. Say for example you have a table like this:\n\nshow_table(db[\"Trees\"].rows)\n\n\nidTreeAddressCommonNameLatinName152 Vine StPalmArecaceae212 Draft StOakQuercus351 Dark AvePalmArecaceae41252 Left StPalmArecaceae\n\n\nYou can pass [\"CommonName\", \"LatinName\"] to .extract() to extract both of those columns:\n\n# db[\"Trees\"].extract([\"CommonName\", \"LatinName\"]) # TODO: see https://github.com/simonw/sqlite-utils/issues/235\n\nThis produces the following schema:\n\nprint(db.schema)\n\nCREATE TABLE \"Trees\" (\n   [id] INTEGER PRIMARY KEY,\n   [TreeAddress] TEXT,\n   [CommonName] TEXT\n, [LatinName] TEXT);\n\n\nThe table name CommonName_LatinName is derived from the extract columns. You can use table= and fk_column= to specify custom names like this:\n\n# db[\"Trees\"].extract([\"CommonName\", \"LatinName\"], table=\"Species\", fk_column=\"species_id\") # TODO: see https://github.com/simonw/sqlite-utils/issues/235\n\nThis produces the following schema:\n\nprint(db.schema)\n\nCREATE TABLE \"Trees\" (\n   [id] INTEGER PRIMARY KEY,\n   [TreeAddress] TEXT,\n   [CommonName] TEXT\n, [LatinName] TEXT);\n\n\nYou can use the rename= argument to rename columns in the lookup table. To create a Species table with columns called name and latin you can do this:\n\n# db[\"Trees\"].extract(\n#     [\"CommonName\", \"LatinName\"],\n#     table=\"Species\",\n#     fk_column=\"species_id\",\n#     rename={\"CommonName\": \"name\", \"LatinName\": \"latin\"}\n# ) # TODO: see https://github.com/simonw/sqlite-utils/issues/235\n\nThis produces a lookup table like so:\n\n# print(db[\"Species\"].schema)"
  },
  {
    "objectID": "python-api.html#setting-an-id-based-on-the-hash-of-the-row-contents",
    "href": "python-api.html#setting-an-id-based-on-the-hash-of-the-row-contents",
    "title": "sqlite_utils Python library",
    "section": "Setting an ID based on the hash of the row contents",
    "text": "Setting an ID based on the hash of the row contents\nSometimes you will find yourself working with a dataset that includes rows that do not have a provided obvious ID, but where you would like to assign one so that you can later upsert into that table without creating duplicate records.\nIn these cases, a useful technique is to create an ID that is derived from the sha1 hash of the row contents.\nsqlite-utils can do this for you using the hash_id= option. For example:\n\ndb = Database(memory=True)\ndogs = db[\"dogs\"].upsert({\"name\": \"Cleo\", \"twitter\": \"cleopaws\"}, hash_id=\"id\")\nprint(list(db[\"dogs\"].rows))\n\n[{'id': 'f501265970505d9825d8d9f590bfab3519fb20b1', 'name': 'Cleo', 'twitter': 'cleopaws'}]\n\n\nIf you are going to use that ID straight away, you can access it using last_pk:\n\ndogs.last_pk\n\n'f501265970505d9825d8d9f590bfab3519fb20b1'\n\n\nThe hash will be created using all of the column values. To create a hash using a subset of the columns, pass the hash_id_columns= parameter:\n\ndb = Database(memory=True)\ndb[\"dogs\"].upsert(\n    {\"name\": \"Cleo\", \"twitter\": \"cleopaws\", \"age\": 7},\n    hash_id_columns=(\"name\", \"twitter\")\n);\n\nThe hash_id= parameter is optional if you specify hash_id_columns= - it will default to putting the hash in a column called id.\nYou can manually calculate these hashes using the hash_record(record, utility function."
  },
  {
    "objectID": "python-api.html#creating-views",
    "href": "python-api.html#creating-views",
    "title": "sqlite_utils Python library",
    "section": "Creating views",
    "text": "Creating views\nThe .create_view() method on the database class can be used to create a view:\n\ndb = Database(memory=True)\ndb.create_view(\"good_dogs\", \"\"\"\n    select * from dogs where is_good_dog = 1\n\"\"\");\n\nThis will raise a sqlite_utils.utils.OperationalError if a view with that name already exists.\nYou can pass ignore=True to silently ignore an existing view and do nothing, or replace=True to replace an existing view with a new definition if your select statement differs from the current view:\n\ndb.create_view(\"good_dogs\", \"\"\"\n    select * from dogs where is_good_dog = 1\n\"\"\", replace=True);"
  },
  {
    "objectID": "python-api.html#storing-json",
    "href": "python-api.html#storing-json",
    "title": "sqlite_utils Python library",
    "section": "Storing JSON",
    "text": "Storing JSON\nSQLite has excellent JSON support, and sqlite-utils can help you take advantage of this: if you attempt to insert a value that can be represented as a JSON list or dictionary, sqlite-utils will create TEXT column and store your data as serialized JSON. This means you can quickly store even complex data structures in SQLite and query them using JSON features.\nFor example:\n\ndb = Database(memory=True)\ndb[\"niche_museums\"].insert({\n    \"name\": \"The Bigfoot Discovery Museum\",\n    \"url\": \"http://bigfootdiscoveryproject.com/\",\n    \"hours\": {\n        \"Monday\": [11, 18],\n        \"Wednesday\": [11, 18],\n        \"Thursday\": [11, 18],\n        \"Friday\": [11, 18],\n        \"Saturday\": [11, 18],\n        \"Sunday\": [11, 18]\n    },\n    \"address\": {\n        \"streetAddress\": \"5497 Highway 9\",\n        \"addressLocality\": \"Felton, CA\",\n        \"postalCode\": \"95018\"\n    }\n})\ndb.execute(\"\"\"\n    select json_extract(address, '$.addressLocality')\n    from niche_museums\n\"\"\").fetchall()\n\n[('Felton, CA',)]"
  },
  {
    "objectID": "python-api.html#converting-column-values-using-sql-functions",
    "href": "python-api.html#converting-column-values-using-sql-functions",
    "title": "sqlite_utils Python library",
    "section": "Converting column values using SQL functions",
    "text": "Converting column values using SQL functions\nSometimes it can be useful to run values through a SQL function prior to inserting them. A simple example might be converting a value to upper case while it is being inserted.\nThe conversions={...} parameter can be used to specify custom SQL to be used as part of a INSERT or UPDATE SQL statement.\nYou can specify an upper case conversion for a specific column like so:\n\ndb = Database(memory=True)\ndb[\"example\"].insert({\n    \"name\": \"The Bigfoot Discovery Museum\"\n}, conversions={\"name\": \"upper(?)\"})\nlist(db[\"example\"].rows)\n\n[{'name': 'THE BIGFOOT DISCOVERY MUSEUM'}]\n\n\nThe dictionary key is the column name to be converted. The value is the SQL fragment to use, with a ? placeholder for the original value.\nA more useful example: if you are working with SpatiaLite you may find yourself wanting to create geometry values from a WKT value. Code to do that could look like this:\n\nfrom shapely.geometry import shape\nimport httpx\n\n\n# TODO\n# db = Database(\"../test/places.db\")\n# # Initialize SpatiaLite\n# db.init_spatialite()\n# # Use sqlite-utils to create a places table\n# places = db[\"places\"].create({\"id\": int, \"name\": str})\n\n# # Add a SpatiaLite 'geometry' column\n# places.add_geometry_column(\"geometry\", \"MULTIPOLYGON\")\n\n# # Fetch some GeoJSON from Who's On First:\n# geojson = httpx.get(\n#     \"https://raw.githubusercontent.com/whosonfirst-data/\"\n#     \"whosonfirst-data-admin-gb/master/data/404/227/475/404227475.geojson\"\n# ).json()\n\n# # Convert to \"Well Known Text\" format using shapely\n# wkt = shape(geojson[\"geometry\"]).wkt\n\n# # Insert the record, converting the WKT to a SpatiaLite geometry:\n# db[\"places\"].insert(\n#     {\"name\": \"Wales\", \"geometry\": wkt},\n#     conversions={\"geometry\": \"GeomFromText(?, 4326)\"},\n# )\n\nThis example uses gographical data from Who’s On First and depends on the Shapely and HTTPX Python libraries."
  },
  {
    "objectID": "python-api.html#checking-the-sqlite-version",
    "href": "python-api.html#checking-the-sqlite-version",
    "title": "sqlite_utils Python library",
    "section": "Checking the SQLite version",
    "text": "Checking the SQLite version\nThe db.sqlite_version property returns a tuple of integers representing the version of SQLite used for that database object:\n\ndb.sqlite_version\n\n(3, 37, 0)"
  },
  {
    "objectID": "python-api.html#introspecting-tables-and-views",
    "href": "python-api.html#introspecting-tables-and-views",
    "title": "sqlite_utils Python library",
    "section": "Introspecting tables and views",
    "text": "Introspecting tables and views\nIf you have loaded an existing table or view, you can use introspection to find out more about it:\n\ndb[\"Trees\"]\n\n<Table Trees (id, TreeAddress, CommonName, LatinName)>\n\n\n\n.exists()\nThe .exists() method can be used to find out if a table exists or not:\n\ndb[\"Trees\"].exists()\n\nTrue\n\n\n\ndb[\"Trees2\"].exists()\n\nFalse\n\n\n\n\n.count\nThe .count property shows the current number of rows (select count(*) from table):\n\ndb[\"Trees\"].count\n\n4\n\n\nThis property will take advantage of python_api_cached_table_counts if the use_counts_table property is set on the database. You can avoid that optimization entirely by calling table.count_where() instead of accessing the property.\n\n\n.columns\nThe .columns property shows the columns in the table or view. It returns a list of Column(cid, name, type, notnull, default_value, is_pk) named tuples.\n\ndb[\"Trees\"].columns\n\n[Column(cid=0, name='id', type='INTEGER', notnull=0, default_value=None, is_pk=1),\n Column(cid=1, name='TreeAddress', type='TEXT', notnull=0, default_value=None, is_pk=0),\n Column(cid=2, name='CommonName', type='TEXT', notnull=0, default_value=None, is_pk=0),\n Column(cid=3, name='LatinName', type='TEXT', notnull=0, default_value=None, is_pk=0)]\n\n\n\n\n.columns_dict\nThe .columns_dict property returns a dictionary version of the columns with just the names and Python types:\n\ndb[\"Trees\"].columns_dict\n\n{'id': int, 'TreeAddress': str, 'CommonName': str, 'LatinName': str}\n\n\n\n\n.pks\nThe .pks property returns a list of strings naming the primary key columns for the table:\n\ndb[\"Trees\"].pks\n\n['id']\n\n\nIf a table has no primary keys but is a rowid table, this property will return ['rowid'].\n\n\n.use_rowid\nAlmost all SQLite tables have a rowid column, but a table with no explicitly defined primary keys must use that rowid as the primary key for identifying individual rows. The .use_rowid property checks to see if a table needs to use the rowid in this way - it returns True if the table has no explicitly defined primary keys and False otherwise.\n\n\n.foreign_keys\nThe .foreign_keys property returns any foreign key relationships for the table, as a list of ForeignKey(table, column, other_table, other_column) named tuples. It is not available on views.\n\ndb[\"Trees\"].foreign_keys\n\n[]\n\n\n\n\n.schema\nThe .schema property outputs the table’s schema as a SQL string:\n\nprint(db[\"Trees\"].schema)\n\nCREATE TABLE \"Trees\" (\n   [id] INTEGER PRIMARY KEY,\n   [TreeAddress] TEXT,\n   [CommonName] TEXT\n, [LatinName] TEXT)\n\n\n\n\n.strict\nThe .strict property identifies if the table is a SQLite STRICT table.\n\ndb[\"Trees\"].strict\n\nFalse\n\n\n\n\n.indexes\nThe .indexes property returns all indexes created for a table, as a list of Index(seq, name, unique, origin, partial, columns) named tuples. It is not available on views.\n\ndb[\"Trees\"].indexes\n\n[]\n\n\n\n\n.xindexes\nThe .xindexes property returns more detailed information about the indexes on the table, using the SQLite PRAGMA index_xinfo() mechanism. It returns a list of XIndex(name, columns) named tuples, where columns is a list of XIndexColumn(seqno, cid, name, desc, coll, key) named tuples.\n\ndb[\"Trees\"].xindexes\n\n[]\n\n\n\n\n.triggers\nThe .triggers property lists database triggers. It can be used on both database and table objects. It returns a list of Trigger(name, table, sql) named tuples.\n\ndb[\"Trees\"].triggers\n\n[]\n\n\n\n\n.triggers_dict\nThe .triggers_dict property returns the triggers for that table as a dictionary mapping their names to their SQL definitions.\n\ndb[\"Trees\"].enable_counts()\ndb[\"Trees\"].triggers_dict\n\n{'Trees_counts_insert': \"CREATE TRIGGER [Trees_counts_insert] AFTER INSERT ON [Trees]\\nBEGIN\\n    INSERT OR REPLACE INTO [_counts]\\n    VALUES (\\n        'Trees',\\n        COALESCE(\\n            (SELECT count FROM [_counts] WHERE [table] = 'Trees'),\\n        0\\n        ) + 1\\n    );\\nEND\",\n 'Trees_counts_delete': \"CREATE TRIGGER [Trees_counts_delete] AFTER DELETE ON [Trees]\\nBEGIN\\n    INSERT OR REPLACE INTO [_counts]\\n    VALUES (\\n        'Trees',\\n        COALESCE(\\n            (SELECT count FROM [_counts] WHERE [table] = 'Trees'),\\n        0\\n        ) - 1\\n    );\\nEND\"}\n\n\nThe same property exists on the database, and will return all triggers across all tables:\n\ndb.triggers_dict\n\n{'Trees_counts_insert': \"CREATE TRIGGER [Trees_counts_insert] AFTER INSERT ON [Trees]\\nBEGIN\\n    INSERT OR REPLACE INTO [_counts]\\n    VALUES (\\n        'Trees',\\n        COALESCE(\\n            (SELECT count FROM [_counts] WHERE [table] = 'Trees'),\\n        0\\n        ) + 1\\n    );\\nEND\",\n 'Trees_counts_delete': \"CREATE TRIGGER [Trees_counts_delete] AFTER DELETE ON [Trees]\\nBEGIN\\n    INSERT OR REPLACE INTO [_counts]\\n    VALUES (\\n        'Trees',\\n        COALESCE(\\n            (SELECT count FROM [_counts] WHERE [table] = 'Trees'),\\n        0\\n        ) - 1\\n    );\\nEND\"}\n\n\n\n\n.detect_fts()\nThe detect_fts() method returns the associated SQLite FTS table name, if one exists for this table. If the table has not been configured for full-text search it returns None.\n\ndb[\"Trees\"].detect_fts()\n\n'Trees_fts'\n\n\n\n\n.virtual_table_using\nThe .virtual_table_using property reveals if a table is a virtual table. It returns None for regular tables and the upper case version of the type of virtual table otherwise. For example:\n\ndb[\"Trees\"].enable_fts([\"TreeAddress\"])\ndb[\"Trees_fts\"].virtual_table_using\n\n'FTS5'\n\n\n\n\n.has_counts_triggers\nThe .has_counts_triggers property shows if a table has been configured with triggers for updating a _counts table, as described in python_api_cached_table_counts.\n\ndb[\"Trees\"].has_counts_triggers\n\nFalse\n\n\n\ndb[\"Trees\"].enable_counts()\ndb[\"Trees\"].has_counts_triggers\n\nTrue"
  },
  {
    "objectID": "python-api.html#full-text-search",
    "href": "python-api.html#full-text-search",
    "title": "sqlite_utils Python library",
    "section": "Full-text search",
    "text": "Full-text search\nSQLite includes bundled extensions that implement powerful full-text search.\n\nEnabling full-text search for a table\nYou can enable full-text search on a table using .enable_fts(columns):\n\ndb[\"dogs\"].enable_fts([\"name\", \"twitter\"]);\n\nYou can then run searches using the .search() method:\n\nrows = list(db[\"dogs\"].search(\"cleo\"))\n\nThis method returns a generator that can be looped over to get dictionaries for each row, similar to python_api_rows.\nIf you insert additional records into the table you will need to refresh the search index using populate_fts():\n\ndb[\"dogs\"].insert({\n    \"id\": 2,\n    \"name\": \"Marnie\",\n    \"twitter\": \"MarnieTheDog\",\n    \"age\": 16,\n    \"is_good_dog\": True,\n}, pk=\"id\")\ndb[\"dogs\"].populate_fts([\"name\", \"twitter\"]);\n\nA better solution is to use database triggers. You can set up database triggers to automatically update the full-text index using create_triggers=True:\n\ndb[\"dogs\"].enable_fts([\"name\", \"twitter\"], create_triggers=True)\n\n<Table dogs (id, age, name, twitter, is_good_dog)>\n\n\n.enable_fts() defaults to using FTS5. If you wish to use FTS4 instead, use the following:\n\ndb[\"dogs\"].enable_fts([\"name\", \"twitter\"], fts_version=\"FTS4\")\n\n<Table dogs (id, age, name, twitter, is_good_dog)>\n\n\nYou can customize the tokenizer configured for the table using the tokenize= parameter. For example, to enable Porter stemming, where English words like “running” will match stemmed alternatives such as “run”, use tokenize=\"porter\":\n\n# db[\"articles\"].enable_fts([\"headline\", \"body\"], tokenize=\"porter\") # TODO\n\nThe SQLite documentation has more on FTS5 tokenizers and FTS4 tokenizers. porter is a valid option for both.\nIf you attempt to configure a FTS table where one already exists, a sqlite3.OperationalError exception will be raised.\nYou can replace the existing table with a new configuration using replace=True:\n\n# db[\"articles\"].enable_fts([\"headline\"], tokenize=\"porter\", replace=True) # TODO\n\nThis will have no effect if the FTS table already exists, otherwise it will drop and recreate the table with the new settings. This takes into consideration the columns, the tokenizer, the FTS version used and whether or not the table has triggers.\nTo remove the FTS tables and triggers you created, use the disable_fts() table method:\n\ndb[\"dogs\"].disable_fts()\n\n<Table dogs (id, age, name, twitter, is_good_dog)>\n\n\n\n\nQuoting characters for use in search\nSQLite supports advanced search query syntax. In some situations you may wish to disable this, since characters such as . may have special meaning that causes errors when searching for strings provided by your users.\nThe db.quote_fts(query) method returns the query with SQLite full-text search quoting applied such that the query should be safe to use in a search:\n\ndb.quote_fts(\"Search term.\")\n\n'\"Search\" \"term.\"'\n\n\n\n\nSearching with table.search()\nThe table.search(q) method returns a generator over Python dictionaries representing rows that match the search phrase q, ordered by relevance with the most relevant results first.\n\n# TODO\n# for article in db[\"articles\"].search(\"jquery\"):\n#     print(article)\n\nThe .search() method also accepts the following optional parameters:\nThe column to sort by. Defaults to relevance score. Can optionally include a desc, e.g. rowid desc.\nColumns to return. Defaults to all columns.\nNumber of results to return. Defaults to all results.\nOffset to use along side the limit parameter.\nExtra SQL fragment for the WHERE clause\nArguments to use for :param placeholders in the extra WHERE clause\nApply FTS quoting rules to the search query, disabling advanced query syntax in a way that avoids surprising errors.\nTo return just the title and published columns for three matches for \"dog\" where the id is greater than 10 ordered by published with the most recent first, use the following:\n\n# TODO\n# for article in db[\"articles\"].search(\n#     \"dog\",\n#     order_by=\"published desc\",\n#     limit=3,\n#     where=\"id > :min_id\",\n#     where_args={\"min_id\": 10},\n#     columns=[\"title\", \"published\"]\n# ):\n#     print(article)\n\n\n\nBuilding SQL queries with table.search_sql()\nYou can generate the SQL query that would be used for a search using the table.search_sql() method. It takes the same arguments as table.search(), with the exception of the search query and the where_args parameter, since those should be provided when the returned SQL is executed.\n\n# TODO\n# print(db[\"articles\"].search_sql(columns=[\"title\", \"author\"]))\n\nOutputs:\nwith original as (\n    select\n        rowid,\n        [title],\n        [author]\n    from [articles]\n)\nselect\n    [original].[title],\n    [original].[author]\nfrom\n    [original]\n    join [articles_fts] on [original].rowid = [articles_fts].rowid\nwhere\n    [articles_fts] match :query\norder by\n    [articles_fts].rank\nThis method detects if a SQLite table uses FTS4 or FTS5, and outputs the correct SQL for ordering by relevance depending on the search type.\nThe FTS4 output looks something like this:\nwith original as (\n    select\n        rowid,\n        [title],\n        [author]\n    from [articles]\n)\nselect\n    [original].[title],\n    [original].[author]\nfrom\n    [original]\n    join [articles_fts] on [original].rowid = [articles_fts].rowid\nwhere\n    [articles_fts] match :query\norder by\n    rank_bm25(matchinfo([articles_fts], 'pcnalx'))\nThis uses the rank_bm25() custom SQL function from sqlite-fts4. You can register that custom function against a Database connection using this method:\n\ndb.register_fts4_bm25()"
  },
  {
    "objectID": "python-api.html#rebuilding-a-full-text-search-table",
    "href": "python-api.html#rebuilding-a-full-text-search-table",
    "title": "sqlite_utils Python library",
    "section": "Rebuilding a full-text search table",
    "text": "Rebuilding a full-text search table\nYou can rebuild a table using the table.rebuild_fts() method. This is useful for if the table configuration changes or the indexed data has become corrupted in some way.\n\n# db[\"dogs\"].rebuild_fts() # TODO\n\nThis method can be called on a table that has been configured for full-text search - dogs in this instance - or directly on a _fts table:\n\n# db[\"dogs_fts\"].rebuild_fts() # TODO\n\nThis runs the following SQL:\nINSERT INTO dogs_fts (dogs_fts) VALUES (\"rebuild\")"
  },
  {
    "objectID": "python-api.html#optimizing-a-full-text-search-table",
    "href": "python-api.html#optimizing-a-full-text-search-table",
    "title": "sqlite_utils Python library",
    "section": "Optimizing a full-text search table",
    "text": "Optimizing a full-text search table\nOnce you have populated a FTS table you can optimize it to dramatically reduce its size like so:\n\ndb[\"dogs\"].optimize();\n\nThis runs the following SQL:\nINSERT INTO dogs_fts (dogs_fts) VALUES (\"optimize\");"
  },
  {
    "objectID": "python-api.html#cached-table-counts-using-triggers",
    "href": "python-api.html#cached-table-counts-using-triggers",
    "title": "sqlite_utils Python library",
    "section": "Cached table counts using triggers",
    "text": "Cached table counts using triggers\nThe select count(*) query in SQLite requires a full scan of the primary key index, and can take an increasingly long time as the table grows larger.\nThe table.enable_counts() method can be used to configure triggers to continuously update a record in a _counts table. This value can then be used to quickly retrieve the count of rows in the associated table.\n\ndb[\"dogs\"].enable_counts()\n\nThis will create the _counts table if it does not already exist, with the following schema:\n\nprint(db[\"_counts\"].schema)\n\nCREATE TABLE [_counts](\n   [table] TEXT PRIMARY KEY,\n   count INTEGER DEFAULT 0\n)\n\n\nYou can enable cached counts for every table in a database (except for virtual tables and the _counts table itself) using the database enable_counts() method:\n\ndb.enable_counts()\n\nOnce enabled, table counts will be stored in the _counts table. The count records will be automatically kept up-to-date by the triggers when rows are added or deleted to the table.\nTo access these counts you can query the _counts table directly or you can use the db.cached_counts() method. This method returns a dictionary mapping tables to their counts:\n\ndb.cached_counts()\n\n{'dogs': 2, 'compound_dogs': 1}\n\n\nYou can pass a list of table names to this method to retrieve just those counts:\n\ndb.cached_counts([\"dogs\"])\n\n{'dogs': 2}\n\n\nThe table.count property executes a select count(*) query by default, unless the db.use_counts_table property is set to True.\nYou can set use_counts_table to True when you instantiate the database object:\n\ndb = Database(\"../test/dogs.db\", use_counts_table=True)\n\nIf the property is True any calls to the table.count property will first attempt to find the cached count in the _counts table, and fall back on a count(*) query if the value is not available or the table is missing.\nCalling the .enable_counts() method on a database or table object will set use_counts_table to True for the lifetime of that database object.\nIf the _counts table ever becomes out-of-sync with the actual table counts you can repair it using the .reset_counts() method:\n\ndb.reset_counts()"
  },
  {
    "objectID": "python-api.html#creating-indexes",
    "href": "python-api.html#creating-indexes",
    "title": "sqlite_utils Python library",
    "section": "Creating indexes",
    "text": "Creating indexes\nYou can create an index on a table using the .create_index(columns) method. The method takes a list of columns:\n\ndb[\"dogs\"].create_index([\"is_good_dog\"]);\n\nBy default the index will be named idx_{table-name}_{columns}. If you pass find_unique_name=True and the automatically derived name already exists, an available name will be found by incrementing a suffix number, for example idx_items_title_2.\nYou can customize the name of the created index by passing the index_name parameter:\n\ndb[\"dogs\"].create_index(\n    [\"is_good_dog\", \"age\"],\n    index_name=\"good_dogs_by_age\"\n);\n\nTo create an index in descending order for a column, wrap the column name in db.DescIndex() like this:\n\nfrom sqlite_utils.db import DescIndex\n\n\ndb[\"dogs\"].create_index(\n    [\"is_good_dog\", DescIndex(\"age\")],\n    index_name=\"good_dogs_by_age\"\n);\n\nYou can create a unique index by passing unique=True:\n\ndb[\"dogs\"].create_index([\"name\"], unique=True);\n\nUse if_not_exists=True to do nothing if an index with that name already exists.\nPass analyze=True to run ANALYZE against the new index after creating it."
  },
  {
    "objectID": "python-api.html#optimizing-index-usage-with-analyze",
    "href": "python-api.html#optimizing-index-usage-with-analyze",
    "title": "sqlite_utils Python library",
    "section": "Optimizing index usage with ANALYZE",
    "text": "Optimizing index usage with ANALYZE\nThe SQLite ANALYZE command builds a table of statistics which the query planner can use to make better decisions about which indexes to use for a given query.\nYou should run ANALYZE if your database is large and you do not think your indexes are being efficiently used.\nTo run ANALYZE against every index in a database, use this:\n\ndb.analyze()\n\nTo run it just against a specific named index, pass the name of the index to that method:\n\ndb.analyze(\"idx_dogs_name\")\n\nTo run against all indexes attached to a specific table, you can either pass the table name to db.analyze(...) or you can call the method directly on the table, like this:\n\ndb[\"dogs\"].analyze()"
  },
  {
    "objectID": "python-api.html#vacuum",
    "href": "python-api.html#vacuum",
    "title": "sqlite_utils Python library",
    "section": "Vacuum",
    "text": "Vacuum\nYou can optimize your database by running VACUUM against it like so:\n\nDatabase(\"../test/my_database.db\").vacuum()"
  },
  {
    "objectID": "python-api.html#wal-mode",
    "href": "python-api.html#wal-mode",
    "title": "sqlite_utils Python library",
    "section": "WAL mode",
    "text": "WAL mode\nYou can enable Write-Ahead Logging for a database with .enable_wal():\n\nDatabase(\"../test/my_database.db\").enable_wal()\n\nYou can disable WAL mode using .disable_wal():\n\nDatabase(\"../test/my_database.db\").disable_wal()\n\nYou can check the current journal mode for a database using the journal_mode property:\n\njournal_mode = Database(\"../test/my_database.db\").journal_mode\n\nThis will usually be wal or delete (meaning WAL is disabled), but can have other values - see the PRAGMA journal_mode documentation."
  },
  {
    "objectID": "python-api.html#suggesting-column-types",
    "href": "python-api.html#suggesting-column-types",
    "title": "sqlite_utils Python library",
    "section": "Suggesting column types",
    "text": "Suggesting column types\nWhen you create a new table for a list of inserted or upserted Python dictionaries, those methods detect the correct types for the database columns based on the data you pass in.\nIn some situations you may need to intervene in this process, to customize the columns that are being created in some way - see python_api_explicit_create.\nThat table .create() method takes a dictionary mapping column names to the Python type they should store:\n\ndb = Database(memory=True)\ndb[\"cats\"].create({\n    \"id\": int,\n    \"name\": str,\n    \"weight\": float,\n});\n\nYou can use the suggest_column_types() helper function to derive a dictionary of column names and types from a list of records, suitable to be passed to table.create().\nFor example:\n\nfrom sqlite_utils import suggest_column_types\n\n\ncats = [{\n    \"id\": 1,\n    \"name\": \"Snowflake\"\n}, {\n    \"id\": 2,\n    \"name\": \"Crabtree\",\n    \"age\": 4\n}]\ntypes = suggest_column_types(cats)\ntypes\n\n{'id': int, 'name': str, 'age': int}\n\n\nManually add an extra field:\n\ntypes[\"thumbnail\"] = bytes\ntypes\n\n{'id': int, 'name': str, 'age': int, 'thumbnail': bytes}\n\n\nCreate the table:\n\ndb = Database(memory=True)\ndb[\"cats\"].create(types, pk=\"id\")\n\n<Table cats (id, name, age, thumbnail)>\n\n\nInsert the records:\n\ndb[\"cats\"].insert_all(cats)\nlist(db[\"cats\"].rows)\n\n[{'id': 1, 'name': 'Snowflake', 'age': None, 'thumbnail': None},\n {'id': 2, 'name': 'Crabtree', 'age': 4, 'thumbnail': None}]\n\n\nThe table schema looks like this:\n\nprint(db[\"cats\"].schema)\n\nCREATE TABLE [cats] (\n   [id] INTEGER PRIMARY KEY,\n   [name] TEXT,\n   [age] INTEGER,\n   [thumbnail] BLOB\n)"
  },
  {
    "objectID": "python-api.html#registering-custom-sql-functions",
    "href": "python-api.html#registering-custom-sql-functions",
    "title": "sqlite_utils Python library",
    "section": "Registering custom SQL functions",
    "text": "Registering custom SQL functions\nSQLite supports registering custom SQL functions written in Python. The db.register_function() method lets you register these functions, and keeps track of functions that have already been registered.\nIf you use it as a method it will automatically detect the name and number of arguments needed by the function:\n\ndb = Database(memory=True)\n\ndef reverse_string(s):\n    return \"\".join(reversed(list(s)))\n\ndb.register_function(reverse_string)\nprint(db.execute('select reverse_string(\"hello\")').fetchone()[0])\n\nolleh\n\n\nYou can also use the method as a function decorator like so:\n\n@db.register_function\ndef reverse_string(s):\n    return \"\".join(reversed(list(s)))\n\nprint(db.execute('select reverse_string(\"hello\")').fetchone()[0])\n\nolleh\n\n\nBy default, the name of the Python function will be used as the name of the SQL function. You can customize this with the name= keyword argument:\n\n@db.register_function(name=\"rev\")\ndef reverse_string(s):\n    return \"\".join(reversed(list(s)))\n\nprint(db.execute('select rev(\"hello\")').fetchone()[0])\n\nolleh\n\n\nPython 3.8 added the ability to register deterministic SQLite functions, allowing you to indicate that a function will return the exact same result for any given inputs and hence allowing SQLite to apply some performance optimizations. You can mark a function as deterministic using deterministic=True, like this:\n\n@db.register_function(deterministic=True)\ndef reverse_string(s):\n    return \"\".join(reversed(list(s)))\n\nIf you run this on a version of Python prior to 3.8 your code will still work, but the deterministic=True parameter will be ignored.\nBy default registering a function with the same name and number of arguments will have no effect - the Database instance keeps track of functions that have already been registered and skips registering them if @db.register_function is called a second time.\nIf you want to deliberately replace the registered function with a new implementation, use the replace=True argument:\n\n@db.register_function(deterministic=True, replace=True)\ndef reverse_string(s):\n    return s[::-1]\n\nExceptions that occur inside a user-defined function default to returning the following error:\nUnexpected error: user-defined function raised exception\nYou can cause sqlite3 to return more useful errors, including the traceback from the custom function, by executing the following before your custom functions are executed:\n\nsqlite3.enable_callback_tracebacks(True)"
  },
  {
    "objectID": "python-api.html#quoting-strings-for-use-in-sql",
    "href": "python-api.html#quoting-strings-for-use-in-sql",
    "title": "sqlite_utils Python library",
    "section": "Quoting strings for use in SQL",
    "text": "Quoting strings for use in SQL\nIn almost all cases you should pass values to your SQL queries using the optional parameters argument to db.query(), as described in python_api_parameters.\nIf that option isn’t relevant to your use-case you can to quote a string for use with SQLite using the db.quote() method, like so:\n\ndb = Database(memory=True)\ndb.quote(\"hello\")\n\n\"'hello'\"\n\n\n\ndb.quote(\"hello'this'has'quotes\")\n\n\"'hello''this''has''quotes'\""
  },
  {
    "objectID": "python-api.html#reading-rows-from-a-file",
    "href": "python-api.html#reading-rows-from-a-file",
    "title": "sqlite_utils Python library",
    "section": "Reading rows from a file",
    "text": "Reading rows from a file\nThe sqlite_utils.utils.rows_from_file() helper function can read rows (a sequence of dictionaries) from CSV, TSV, JSON or newline-delimited JSON files.\nNote: removed autofunction:: sqlite_utils.utils.rows_from_file here. We would use show_doc."
  },
  {
    "objectID": "python-api.html#setting-the-maximum-csv-field-size-limit",
    "href": "python-api.html#setting-the-maximum-csv-field-size-limit",
    "title": "sqlite_utils Python library",
    "section": "Setting the maximum CSV field size limit",
    "text": "Setting the maximum CSV field size limit\nSometimes when working with CSV files that include extremely long fields you may see an error that looks like this:\n_csv.Error: field larger than field limit (131072)\nThe Python standard library csv module enforces a field size limit. You can increase that limit using the csv.field_size_limit(new_limit) method (documented here) but if you don’t want to pick a new level you may instead want to increase it to the maximum possible.\nThe maximum possible value for this is not documented, and varies between systems.\nCalling sqlite_utils.utils.maximize_csv_field_size_limit() will set the value to the highest possible for the current system:\n\nfrom sqlite_utils.utils import maximize_csv_field_size_limit\n\n\nmaximize_csv_field_size_limit()\n\nIf you need to reset to the original value after calling this function you can do so like this:\n\nfrom sqlite_utils.utils import ORIGINAL_CSV_FIELD_SIZE_LIMIT\nimport csv\n\n\ncsv.field_size_limit(ORIGINAL_CSV_FIELD_SIZE_LIMIT)\n\n9223372036854775807"
  },
  {
    "objectID": "python-api.html#detecting-column-types-using-typetracker",
    "href": "python-api.html#detecting-column-types-using-typetracker",
    "title": "sqlite_utils Python library",
    "section": "Detecting column types using TypeTracker",
    "text": "Detecting column types using TypeTracker\nSometimes you may find yourself working with data that lacks type information - data from a CSV file for example.\nThe TypeTracker class can be used to try to automatically identify the most likely types for data that is initially represented as strings.\nConsider this example:\n\nimport csv, io\n\n\ncsv_file = io.StringIO(\"id,name\\n1,Cleo\\n2,Cardi\")\nrows = list(csv.DictReader(csv_file))\nrows\n\n[{'id': '1', 'name': 'Cleo'}, {'id': '2', 'name': 'Cardi'}]\n\n\nIf we insert this data directly into a table we will get a schema that is entirely TEXT columns:\n\ndb = Database(memory=True)\ndb[\"creatures\"].insert_all(rows)\nprint(db.schema)\n\nCREATE TABLE [creatures] (\n   [id] TEXT,\n   [name] TEXT\n);\n\n\nWe can detect the best column types using a TypeTracker instance:\n\nfrom sqlite_utils.utils import TypeTracker\n\n\ntracker = TypeTracker()\ndb[\"creatures2\"].insert_all(tracker.wrap(rows))\nprint(tracker.types)\n\n{'id': 'integer', 'name': 'text'}\n\n\nWe can then apply those types to our new table using the table.transform() method:\n\ndb[\"creatures2\"].transform(types=tracker.types)\nprint(db[\"creatures2\"].schema)\n\nCREATE TABLE \"creatures2\" (\n   [id] INTEGER,\n   [name] TEXT\n)"
  },
  {
    "objectID": "python-api.html#spatialite-helpers",
    "href": "python-api.html#spatialite-helpers",
    "title": "sqlite_utils Python library",
    "section": "SpatiaLite helpers",
    "text": "SpatiaLite helpers\nSpatiaLite is a geographic extension to SQLite (similar to PostgreSQL + PostGIS). Using requires finding, loading and initializing the extension, adding geometry columns to existing tables and optionally creating spatial indexes. The utilities here help streamline that setup.\n\nInitialize SpatiaLite\nNote: removed automethod:: sqlite_utils.db.Database.init_spatialite. We would use show_doc.\n\n\nFinding SpatiaLite\nNote: removed autofunction:: sqlite_utils.utils.find_spatialite. We would use show_doc.\n\n\nAdding geometry columns\nNote: removed autofunction:: sqlite_utils.db.Table.add_geometry_column. We would use show_doc.\n\n\nCreating a spatial index\nNote: removed autofunction:: sqlite_utils.db.Table.create_spatial_index. We would use show_doc."
  }
]